# diff --git a/default_config.toml b/default_config.toml
# index 9e803d9..6b10e20 100644
# --- a/default_config.toml
# +++ b/default_config.toml
# @@ -86,7 +86,7 @@ goto_start = ["S"]
#  goto_top = ["Home"]
#  goto_bottom = ["End"]
#  save_state_file = ["Command+S"]
# -group_new = ["G"]
# +group_new = ["G", "Command+G"]
#  item_focus = ["F"]
#  select_all = ["Command+A"]
#  select_toggle = ["A"]
# @@ -102,4 +102,4 @@ marker_add = ["M"]
#  toggle_menu = ["Alt+M"]
#  show_command_prompt = ["Space"]
#  rename_item = ["F2"]
# -divider_add = ["D"]
# +divider_add = ["D", "Command+D"]
diff --git a/libsurfer/src/hierarchy.rs b/libsurfer/src/hierarchy.rs
index abcecc3..74bbe6f 100644
--- a/libsurfer/src/hierarchy.rs
+++ b/libsurfer/src/hierarchy.rs
@@ -367,6 +367,8 @@ impl SystemState {
             let variables = wave_container.variables_in_scope(&scope);
             self.filter_and_draw_variable_list(msgs, wave_container, ui, &variables, None);
         }
+        // Clear restore flag after all scopes have been rendered
+        self.restore_expanded_scopes.set(false);
     }
 
     fn add_scope_selectable_label(
@@ -511,15 +513,21 @@ impl SystemState {
             });
         } else {
             let should_open_header = self.should_open_header_and_scroll_to(scope);
+            let is_in_expanded_set = wave.expanded_scopes.contains(scope);
+            let scope_egui_id = egui::Id::new(scope);
             let mut collapsing_header =
                 egui::collapsing_header::CollapsingState::load_with_default_open(
                     ui.ctx(),
-                    egui::Id::new(scope),
-                    false,
+                    scope_egui_id,
+                    is_in_expanded_set,
                 );
             if let Some((header_state, _)) = should_open_header {
                 collapsing_header.set_open(header_state);
             }
+            // Force-restore expansion state after loading a state file
+            if self.restore_expanded_scopes.get() {
+                collapsing_header.set_open(is_in_expanded_set);
+            }
             collapsing_header
                 .show_header(ui, |ui| {
                     ui.with_layout(
@@ -560,6 +568,12 @@ impl SystemState {
                         );
                     }
                 });
+            // Track expansion state changes (re-load from egui memory since show_header consumed self)
+            let is_open = egui::collapsing_header::CollapsingState::load(ui.ctx(), scope_egui_id)
+                .map_or(false, |s| s.is_open());
+            if is_open != is_in_expanded_set {
+                msgs.push(Message::SetScopeExpanded(scope.clone(), is_open));
+            }
         }
     }
 
diff --git a/libsurfer/src/lib.rs b/libsurfer/src/lib.rs
index 26a8f83..c6c4ad6 100644
--- a/libsurfer/src/lib.rs
+++ b/libsurfer/src/lib.rs
@@ -153,6 +153,34 @@ pub struct StartupParams {
 fn setup_custom_font(ctx: &egui::Context) {
     let mut fonts = FontDefinitions::default();
 
+    // Load system CJK font for Chinese/Japanese/Korean character support
+    #[cfg(target_os = "macos")]
+    {
+        let cjk_font_paths = [
+            "/System/Library/Fonts/PingFang.ttc",
+            "/System/Library/Fonts/Supplemental/Arial Unicode.ttf",
+        ];
+        for path in &cjk_font_paths {
+            if let Ok(bytes) = std::fs::read(path) {
+                let font_data = FontData::from_owned(bytes);
+                fonts
+                    .font_data
+                    .insert("cjk_fallback".to_owned(), font_data.into());
+                fonts
+                    .families
+                    .get_mut(&FontFamily::Proportional)
+                    .unwrap()
+                    .push("cjk_fallback".to_owned());
+                fonts
+                    .families
+                    .get_mut(&FontFamily::Monospace)
+                    .unwrap()
+                    .push("cjk_fallback".to_owned());
+                break;
+            }
+        }
+    }
+
     fonts.font_data.insert(
         "remix_icons".to_owned(),
         FontData::from_static(egui_remixicon::FONT).into(),
@@ -181,16 +209,25 @@ pub fn run_egui(cc: &CreationContext, mut state: SystemState) -> Result<Box<dyn
         .set_visuals_of(egui::Theme::Dark, state.get_visuals());
     cc.egui_ctx
         .set_visuals_of(egui::Theme::Light, state.get_visuals());
+    // Immediately apply visuals so the saved theme takes effect on startup
+    cc.egui_ctx.set_visuals(state.get_visuals());
     cc.egui_ctx.all_styles_mut(|style| {
         if state.user.config.animation_time == 0.0 {
             info!("With animation_time set to 0.0, animations cannot be enabled.");
         }
-        style.animation_time = if state.user.config.animation_enabled() {
+        // Respect saved animation preference
+        let anim_enabled = state.user.animation_enabled
+            .unwrap_or_else(|| state.user.config.animation_enabled());
+        style.animation_time = if anim_enabled {
             state.user.config.animation_time
         } else {
             0.0
         };
     });
+    // Restore saved UI zoom factor
+    if let Some(zoom) = state.user.ui_zoom_factor {
+        cc.egui_ctx.set_zoom_factor(zoom);
+    }
     #[cfg(not(target_arch = "wasm32"))]
     if state.user.config.wcp.autostart {
         state.start_wcp_server(Some(state.user.config.wcp.address.clone()), false);
@@ -280,7 +317,42 @@ struct CanvasState {
 }
 
 impl SystemState {
+    /// Check if a message represents a user preference change that should be persisted
+    fn is_preference_change(msg: &Message) -> bool {
+        matches!(
+            msg,
+            Message::SetNameAlignRight(_)
+                | Message::SetSidePanelVisible(_)
+                | Message::SetMenuVisible(_)
+                | Message::ToggleMenu
+                | Message::SetToolbarVisible(_)
+                | Message::SetShowEmptyScopes(_)
+                | Message::SetShowHierarchyIcons(_)
+                | Message::SetParameterDisplayLocation(_)
+                | Message::SetStatusbarVisible(_)
+                | Message::SetTickLines(_)
+                | Message::SetVariableTooltip(_)
+                | Message::SetScopeTooltip(_)
+                | Message::SetOverviewVisible(_)
+                | Message::SetShowVariableDirection(_)
+                | Message::SetTransitionValue(_)
+                | Message::SetShowIndices(_)
+                | Message::SetHighlightFocused(_)
+                | Message::SetClockHighlightType(_)
+                | Message::SetFillHighValues(_)
+                | Message::SetDinotraceStyle(_)
+                | Message::SetHierarchyStyle(_)
+                | Message::SetArrowKeyBindings(_)
+                | Message::SetPrimaryMouseDragBehavior(_)
+                | Message::SetDefaultTimeline(_)
+                | Message::SetUIZoomFactor(_)
+                | Message::EnableAnimations(_)
+                | Message::SelectTheme(_)
+        )
+    }
+
     pub fn update(&mut self, message: Message) -> Option<()> {
+        let should_save_prefs = Self::is_preference_change(&message);
         if tracing::enabled!(tracing::Level::TRACE)
             && !matches!(message, Message::CommandPromptUpdate { .. })
         {
@@ -294,6 +366,15 @@ impl SystemState {
             Message::ExpandScope(scope_ref) => {
                 *self.scope_ref_to_expand.borrow_mut() = Some(scope_ref);
             }
+            Message::SetScopeExpanded(scope, expanded) => {
+                if let Some(waves) = &mut self.user.waves {
+                    if expanded {
+                        waves.expanded_scopes.insert(scope);
+                    } else {
+                        waves.expanded_scopes.remove(&scope);
+                    }
+                }
+            }
             Message::AddVariables(vars) => {
                 if !vars.is_empty() {
                     let undo_msg = if vars.len() == 1 {
@@ -2116,10 +2197,16 @@ impl SystemState {
                 }
             }
             Message::SelectTheme(theme_name) => {
-                let theme = SurferTheme::new(theme_name)
+                let theme = SurferTheme::new(theme_name.clone())
                     .with_context(|| "Failed to set theme")
                     .ok()?;
                 self.user.config.theme = theme;
+                self.user.theme_name = theme_name.clone();
+                // Persist theme preference to config directory
+                #[cfg(not(target_arch = "wasm32"))]
+                if let Some(ref name) = theme_name {
+                    crate::state::UserState::save_theme_preference(name);
+                }
                 let ctx = self.context.as_ref()?;
                 ctx.set_visuals(self.get_visuals());
             }
@@ -2148,6 +2235,13 @@ impl SystemState {
             }
             Message::AddCharToPrompt(c) => *self.char_to_add_to_prompt.borrow_mut() = Some(c),
         }
+
+        // Persist user preferences to disk when a setting changes
+        #[cfg(not(target_arch = "wasm32"))]
+        if should_save_prefs {
+            self.user.save_preferences();
+        }
+
         Some(())
     }
 
diff --git a/libsurfer/src/message.rs b/libsurfer/src/message.rs
index 9f795b7..b8b1d05 100644
--- a/libsurfer/src/message.rs
+++ b/libsurfer/src/message.rs
@@ -73,6 +73,8 @@ pub enum Message {
     /// Set active scope, None corresponds to the top-level scope.
     SetActiveScope(Option<ScopeType>),
     ExpandScope(ScopeExpandType),
+    /// Track scope expansion state change in hierarchy view
+    SetScopeExpanded(ScopeRef, bool),
     /// Add one or more variables to wave view.
     AddVariables(Vec<VariableRef>),
     /// Add scope to wave view. If second argument is true, add subscopes recursively.
diff --git a/libsurfer/src/state.rs b/libsurfer/src/state.rs
index 659f69d..170f8cd 100644
--- a/libsurfer/src/state.rs
+++ b/libsurfer/src/state.rs
@@ -74,6 +74,9 @@ pub struct UserState {
     pub(crate) autoload_sibling_state_files: Option<AutoLoad>,
     #[serde(default)]
     pub(crate) autoreload_files: Option<AutoLoad>,
+    /// Saved theme name to restore when loading state
+    #[serde(default)]
+    pub(crate) theme_name: Option<String>,
 
     pub(crate) waves: Option<WaveData>,
     pub(crate) drag_started: bool,
@@ -143,15 +146,258 @@ impl std::fmt::Debug for UserState {
     }
 }
 
+/// Struct to persist user-changeable settings across app restarts.
+/// Saved as JSON to the config directory alongside last_theme.
+#[derive(Serialize, Deserialize, Default)]
+pub struct UserPreferences {
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub show_hierarchy: Option<bool>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub show_menu: Option<bool>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub show_ticks: Option<bool>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub show_toolbar: Option<bool>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub show_tooltip: Option<bool>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub show_scope_tooltip: Option<bool>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub show_default_timeline: Option<bool>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub show_overview: Option<bool>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub show_statusbar: Option<bool>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub align_names_right: Option<bool>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub show_variable_indices: Option<bool>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub show_variable_direction: Option<bool>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub show_empty_scopes: Option<bool>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub show_hierarchy_icons: Option<bool>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub show_parameters_in_scopes: Option<bool>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub parameter_display_location: Option<ParameterDisplayLocation>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub highlight_focused: Option<bool>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub fill_high_values: Option<bool>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub primary_button_drag_behavior: Option<PrimaryMouseDrag>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub arrow_key_bindings: Option<ArrowKeyBindings>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub clock_highlight_type: Option<ClockHighlightType>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub hierarchy_style: Option<HierarchyStyle>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub transition_value: Option<TransitionValue>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub animation_enabled: Option<bool>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub use_dinotrace_style: Option<bool>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub ui_zoom_factor: Option<f32>,
+    #[serde(default, skip_serializing_if = "Option::is_none")]
+    pub theme_name: Option<String>,
+}
+
+impl UserPreferences {
+    /// Capture current user settings into a preferences struct
+    pub fn from_user_state(state: &UserState) -> Self {
+        Self {
+            show_hierarchy: state.show_hierarchy,
+            show_menu: state.show_menu,
+            show_ticks: state.show_ticks,
+            show_toolbar: state.show_toolbar,
+            show_tooltip: state.show_tooltip,
+            show_scope_tooltip: state.show_scope_tooltip,
+            show_default_timeline: state.show_default_timeline,
+            show_overview: state.show_overview,
+            show_statusbar: state.show_statusbar,
+            align_names_right: state.align_names_right,
+            show_variable_indices: state.show_variable_indices,
+            show_variable_direction: state.show_variable_direction,
+            show_empty_scopes: state.show_empty_scopes,
+            show_hierarchy_icons: state.show_hierarchy_icons,
+            show_parameters_in_scopes: state.show_parameters_in_scopes,
+            parameter_display_location: state.parameter_display_location,
+            highlight_focused: state.highlight_focused,
+            fill_high_values: state.fill_high_values,
+            primary_button_drag_behavior: state.primary_button_drag_behavior,
+            arrow_key_bindings: state.arrow_key_bindings,
+            clock_highlight_type: state.clock_highlight_type,
+            hierarchy_style: state.hierarchy_style,
+            transition_value: state.transition_value,
+            animation_enabled: state.animation_enabled,
+            use_dinotrace_style: state.use_dinotrace_style,
+            ui_zoom_factor: state.ui_zoom_factor,
+            theme_name: state.theme_name.clone(),
+        }
+    }
+
+    /// Apply saved preferences to a UserState
+    pub fn apply_to(&self, state: &mut UserState) {
+        if self.show_hierarchy.is_some() { state.show_hierarchy = self.show_hierarchy; }
+        if self.show_menu.is_some() { state.show_menu = self.show_menu; }
+        if self.show_ticks.is_some() { state.show_ticks = self.show_ticks; }
+        if self.show_toolbar.is_some() { state.show_toolbar = self.show_toolbar; }
+        if self.show_tooltip.is_some() { state.show_tooltip = self.show_tooltip; }
+        if self.show_scope_tooltip.is_some() { state.show_scope_tooltip = self.show_scope_tooltip; }
+        if self.show_default_timeline.is_some() { state.show_default_timeline = self.show_default_timeline; }
+        if self.show_overview.is_some() { state.show_overview = self.show_overview; }
+        if self.show_statusbar.is_some() { state.show_statusbar = self.show_statusbar; }
+        if self.align_names_right.is_some() { state.align_names_right = self.align_names_right; }
+        if self.show_variable_indices.is_some() { state.show_variable_indices = self.show_variable_indices; }
+        if self.show_variable_direction.is_some() { state.show_variable_direction = self.show_variable_direction; }
+        if self.show_empty_scopes.is_some() { state.show_empty_scopes = self.show_empty_scopes; }
+        if self.show_hierarchy_icons.is_some() { state.show_hierarchy_icons = self.show_hierarchy_icons; }
+        if self.show_parameters_in_scopes.is_some() { state.show_parameters_in_scopes = self.show_parameters_in_scopes; }
+        if self.parameter_display_location.is_some() { state.parameter_display_location = self.parameter_display_location; }
+        if self.highlight_focused.is_some() { state.highlight_focused = self.highlight_focused; }
+        if self.fill_high_values.is_some() { state.fill_high_values = self.fill_high_values; }
+        if self.primary_button_drag_behavior.is_some() { state.primary_button_drag_behavior = self.primary_button_drag_behavior; }
+        if self.arrow_key_bindings.is_some() { state.arrow_key_bindings = self.arrow_key_bindings; }
+        if self.clock_highlight_type.is_some() { state.clock_highlight_type = self.clock_highlight_type; }
+        if self.hierarchy_style.is_some() { state.hierarchy_style = self.hierarchy_style; }
+        if self.transition_value.is_some() { state.transition_value = self.transition_value; }
+        if self.animation_enabled.is_some() { state.animation_enabled = self.animation_enabled; }
+        if self.use_dinotrace_style.is_some() { state.use_dinotrace_style = self.use_dinotrace_style; }
+        if self.ui_zoom_factor.is_some() { state.ui_zoom_factor = self.ui_zoom_factor; }
+        if self.theme_name.is_some() { state.theme_name = self.theme_name.clone(); }
+    }
+}
+
 impl UserState {
     pub fn new(force_default_config: bool) -> Result<UserState> {
-        let config = SurferConfig::new(force_default_config)
+        Self::new_with_theme(force_default_config, None)
+    }
+
+    pub fn new_with_theme(force_default_config: bool, theme_name: Option<String>) -> Result<UserState> {
+        let mut config = SurferConfig::new(force_default_config)
             .with_context(|| "Failed to load config file")?;
 
-        Ok(UserState {
+        // Load saved preferences from disk
+        #[cfg(not(target_arch = "wasm32"))]
+        let saved_prefs = Self::load_preferences();
+        #[cfg(target_arch = "wasm32")]
+        let saved_prefs = None;
+
+        // Priority: explicit param > saved preference > config file > default
+        let theme_name = theme_name
+            .or_else(|| {
+                saved_prefs.as_ref().and_then(|p| p.theme_name.clone())
+            })
+            .or_else(|| {
+                #[cfg(not(target_arch = "wasm32"))]
+                { Self::load_theme_preference() }
+                #[cfg(target_arch = "wasm32")]
+                { None }
+            })
+            .or_else(|| {
+                Self::read_theme_from_config(force_default_config)
+            });
+
+        // Apply the resolved theme to config
+        if let Some(ref name) = theme_name {
+            if let Ok(theme) = crate::config::SurferTheme::new(Some(name.clone())) {
+                config.theme = theme;
+            }
+        }
+
+        let mut state = UserState {
             config,
+            theme_name,
             ..Default::default()
-        })
+        };
+
+        // Apply all saved preferences (overrides) to the new state
+        #[cfg(not(target_arch = "wasm32"))]
+        if let Some(prefs) = saved_prefs {
+            prefs.apply_to(&mut state);
+        }
+
+        Ok(state)
+    }
+
+    #[cfg(not(target_arch = "wasm32"))]
+    fn read_theme_from_config(_force_default: bool) -> Option<String> {
+        use config::{Config, File};
+
+        let default_config = include_str!("../../default_config.toml");
+        let mut config_builder = Config::builder()
+            .add_source(config::File::from_str(default_config, config::FileFormat::Toml));
+
+        // Try to read from user config
+        if let Some(proj_dirs) = &*crate::config::PROJECT_DIR {
+            let config_file = proj_dirs.config_dir().join("config.toml");
+            config_builder = config_builder.add_source(File::from(config_file).required(false));
+        }
+
+        // Try to read theme field
+        config_builder.build().ok()
+            .and_then(|cfg| cfg.get_string("theme").ok())
+            .filter(|s| !s.is_empty())
+    }
+
+    #[cfg(target_arch = "wasm32")]
+    fn read_theme_from_config(_force_default: bool) -> Option<String> {
+        None
+    }
+
+    /// Save theme preference to a file in the config directory
+    /// so it persists across app restarts without needing state files
+    #[cfg(not(target_arch = "wasm32"))]
+    pub fn save_theme_preference(theme_name: &str) {
+        if let Some(proj_dirs) = &*crate::config::PROJECT_DIR {
+            let config_dir = proj_dirs.config_dir();
+            let _ = std::fs::create_dir_all(config_dir);
+            let pref_file = config_dir.join("last_theme");
+            let _ = std::fs::write(pref_file, theme_name);
+        }
+    }
+
+    /// Load the last saved theme preference from config directory
+    #[cfg(not(target_arch = "wasm32"))]
+    pub fn load_theme_preference() -> Option<String> {
+        if let Some(proj_dirs) = &*crate::config::PROJECT_DIR {
+            let pref_file = proj_dirs.config_dir().join("last_theme");
+            std::fs::read_to_string(pref_file).ok().filter(|s| !s.is_empty())
+        } else {
+            None
+        }
+    }
+
+    /// Save all user preferences (settings overrides) to a JSON file
+    /// in the config directory so they persist across restarts
+    #[cfg(not(target_arch = "wasm32"))]
+    pub fn save_preferences(&self) {
+        let prefs = UserPreferences::from_user_state(self);
+        if let Some(proj_dirs) = &*crate::config::PROJECT_DIR {
+            let config_dir = proj_dirs.config_dir();
+            let _ = std::fs::create_dir_all(config_dir);
+            let pref_file = config_dir.join("preferences.json");
+            if let Ok(json) = serde_json::to_string_pretty(&prefs) {
+                let _ = std::fs::write(pref_file, json);
+            }
+        }
+    }
+
+    /// Load saved user preferences from the config directory
+    #[cfg(not(target_arch = "wasm32"))]
+    pub fn load_preferences() -> Option<UserPreferences> {
+        if let Some(proj_dirs) = &*crate::config::PROJECT_DIR {
+            let pref_file = proj_dirs.config_dir().join("preferences.json");
+            std::fs::read_to_string(pref_file)
+                .ok()
+                .and_then(|s| serde_json::from_str(&s).ok())
+        } else {
+            None
+        }
     }
 }
 
@@ -183,6 +429,7 @@ impl Default for UserState {
             hierarchy_style: None,
             autoload_sibling_state_files: None,
             autoreload_files: None,
+            theme_name: None,
             waves: None,
             drag_started: false,
             drag_source_idx: None,
@@ -347,6 +594,7 @@ impl SystemState {
                             display_item_ref_counter: 0,
                             old_num_timestamps: None,
                             graphics: HashMap::new(),
+                            expanded_scopes: HashSet::new(),
                             cache_generation: 0,
                             inflight_caches: HashMap::new(),
                         },
@@ -406,6 +654,7 @@ impl SystemState {
             display_item_ref_counter: 0,
             old_num_timestamps: None,
             graphics: HashMap::new(),
+            expanded_scopes: HashSet::new(),
             cache_generation: 0,
             inflight_caches: HashMap::new(),
         };
@@ -493,9 +742,70 @@ impl SystemState {
     }
 
     pub(crate) fn load_state(&mut self, mut loaded_state: Box<UserState>, path: Option<PathBuf>) {
+        // config is #[serde(skip)], so loaded_state.config is Default.
+        // Save the theme_name from loaded state before swap.
+        let loaded_theme_name = loaded_state.theme_name.clone();
+
+        // Save current user preferences before swap, so we can restore settings
+        // that the loaded state file doesn't explicitly override.
+        #[cfg(not(target_arch = "wasm32"))]
+        let saved_prefs = UserPreferences::from_user_state(&self.user);
+
         // first swap everything, fix special cases afterwards
         mem::swap(&mut self.user, &mut loaded_state);
 
+        // Restore the real config (not the default one from deserialization)
+        // After swap: self.user has loaded data with default config,
+        //             loaded_state (old) has our real config
+        mem::swap(&mut self.user.config, &mut loaded_state.config);
+
+        // Restore user preferences: for each setting, prefer the value from
+        // the loaded state file if explicitly set, otherwise keep the saved preference.
+        #[cfg(not(target_arch = "wasm32"))]
+        {
+            if self.user.show_hierarchy.is_none() { self.user.show_hierarchy = saved_prefs.show_hierarchy; }
+            if self.user.show_menu.is_none() { self.user.show_menu = saved_prefs.show_menu; }
+            if self.user.show_ticks.is_none() { self.user.show_ticks = saved_prefs.show_ticks; }
+            if self.user.show_toolbar.is_none() { self.user.show_toolbar = saved_prefs.show_toolbar; }
+            if self.user.show_tooltip.is_none() { self.user.show_tooltip = saved_prefs.show_tooltip; }
+            if self.user.show_scope_tooltip.is_none() { self.user.show_scope_tooltip = saved_prefs.show_scope_tooltip; }
+            if self.user.show_default_timeline.is_none() { self.user.show_default_timeline = saved_prefs.show_default_timeline; }
+            if self.user.show_overview.is_none() { self.user.show_overview = saved_prefs.show_overview; }
+            if self.user.show_statusbar.is_none() { self.user.show_statusbar = saved_prefs.show_statusbar; }
+            if self.user.align_names_right.is_none() { self.user.align_names_right = saved_prefs.align_names_right; }
+            if self.user.show_variable_indices.is_none() { self.user.show_variable_indices = saved_prefs.show_variable_indices; }
+            if self.user.show_variable_direction.is_none() { self.user.show_variable_direction = saved_prefs.show_variable_direction; }
+            if self.user.show_empty_scopes.is_none() { self.user.show_empty_scopes = saved_prefs.show_empty_scopes; }
+            if self.user.show_hierarchy_icons.is_none() { self.user.show_hierarchy_icons = saved_prefs.show_hierarchy_icons; }
+            if self.user.show_parameters_in_scopes.is_none() { self.user.show_parameters_in_scopes = saved_prefs.show_parameters_in_scopes; }
+            if self.user.parameter_display_location.is_none() { self.user.parameter_display_location = saved_prefs.parameter_display_location; }
+            if self.user.highlight_focused.is_none() { self.user.highlight_focused = saved_prefs.highlight_focused; }
+            if self.user.fill_high_values.is_none() { self.user.fill_high_values = saved_prefs.fill_high_values; }
+            if self.user.primary_button_drag_behavior.is_none() { self.user.primary_button_drag_behavior = saved_prefs.primary_button_drag_behavior; }
+            if self.user.arrow_key_bindings.is_none() { self.user.arrow_key_bindings = saved_prefs.arrow_key_bindings; }
+            if self.user.clock_highlight_type.is_none() { self.user.clock_highlight_type = saved_prefs.clock_highlight_type; }
+            if self.user.hierarchy_style.is_none() { self.user.hierarchy_style = saved_prefs.hierarchy_style; }
+            if self.user.transition_value.is_none() { self.user.transition_value = saved_prefs.transition_value; }
+            if self.user.animation_enabled.is_none() { self.user.animation_enabled = saved_prefs.animation_enabled; }
+            if self.user.use_dinotrace_style.is_none() { self.user.use_dinotrace_style = saved_prefs.use_dinotrace_style; }
+            if self.user.ui_zoom_factor.is_none() { self.user.ui_zoom_factor = saved_prefs.ui_zoom_factor; }
+        }
+
+        // Restore the theme_name from the loaded state file
+        self.user.theme_name = loaded_theme_name;
+
+        // If loaded state had a saved theme, apply it
+        if let Some(ref theme_name) = self.user.theme_name {
+            if let Ok(new_theme) = crate::config::SurferTheme::new(Some(theme_name.clone())) {
+                self.user.config.theme = new_theme;
+            }
+        }
+
+        // Apply visuals to egui context
+        if let Some(ctx) = self.context.as_ref() {
+            ctx.set_visuals(self.get_visuals());
+        }
+
         // swap back waves for inner, source, format since we want to keep the file
         // fix up all wave references from paths if a wave is loaded
         mem::swap(&mut loaded_state.waves, &mut self.user.waves);
@@ -511,6 +821,7 @@ impl SystemState {
             mem::swap(&mut waves.cursor, &mut new_waves.cursor);
             mem::swap(&mut waves.markers, &mut new_waves.markers);
             mem::swap(&mut waves.focused_item, &mut new_waves.focused_item);
+            mem::swap(&mut waves.expanded_scopes, &mut new_waves.expanded_scopes);
             waves.default_variable_name_type = new_waves.default_variable_name_type;
             waves.scroll_offset = new_waves.scroll_offset;
             load_commands
@@ -521,6 +832,9 @@ impl SystemState {
             self.load_variables(load_commands);
         }
 
+        // Force restore scope expansion state from the loaded state file
+        self.restore_expanded_scopes.set(true);
+
         // reset drag to avoid confusion
         self.user.drag_started = false;
         self.user.drag_source_idx = None;
diff --git a/libsurfer/src/system_state.rs b/libsurfer/src/system_state.rs
index 7e34255..5316cf0 100644
--- a/libsurfer/src/system_state.rs
+++ b/libsurfer/src/system_state.rs
@@ -1,6 +1,6 @@
 use eyre::Result;
 use std::{
-    cell::RefCell,
+    cell::{Cell, RefCell},
     collections::{HashMap, VecDeque},
     sync::{Arc, atomic::AtomicBool},
 };
@@ -82,6 +82,8 @@ pub struct SystemState {
     pub(crate) char_to_add_to_prompt: RefCell<Option<char>>,
     // This item works with the expand scope feature to determine what hierarchys to open
     pub scope_ref_to_expand: RefCell<Option<ScopeExpandType>>,
+    /// When true, force-restore CollapsingState from expanded_scopes on next render
+    pub(crate) restore_expanded_scopes: Cell<bool>,
 
     // Benchmarking stuff
     /// Invalidate draw commands every frame to make performance comparison easier
@@ -143,6 +145,7 @@ impl SystemState {
             items_to_expand: RefCell::new(vec![]),
             char_to_add_to_prompt: RefCell::new(None),
             scope_ref_to_expand: RefCell::new(None),
+            restore_expanded_scopes: Cell::new(false),
             surver_selected_file: RefCell::new(None),
             surver_load_options: RefCell::new(LoadOptions::Clear),
             expand_parameter_section: false,
diff --git a/libsurfer/src/wave_data.rs b/libsurfer/src/wave_data.rs
index e796e23..a2ec6f9 100644
--- a/libsurfer/src/wave_data.rs
+++ b/libsurfer/src/wave_data.rs
@@ -1,4 +1,4 @@
-use std::collections::HashMap;
+use std::collections::{HashMap, HashSet};
 
 use eyre::{Result, WrapErr};
 use num::bigint::ToBigInt as _;
@@ -69,6 +69,9 @@ pub struct WaveData {
     pub scroll_offset: f32,
     pub display_variable_indices: bool,
     pub graphics: HashMap<GraphicId, Graphic>,
+    /// Set of expanded scopes in the hierarchy view, used for persistence
+    #[serde(default)]
+    pub expanded_scopes: HashSet<ScopeRef>,
     /// These are just stored during operation, so no need to serialize
     #[serde(skip)]
     pub drawing_infos: Vec<ItemDrawingInfo>,
@@ -200,6 +203,7 @@ impl WaveData {
             drawing_infos: vec![],
             top_item_draw_offset: 0.,
             graphics: HashMap::new(),
+            expanded_scopes: self.expanded_scopes,
             total_height: 0.,
             old_num_timestamps,
             cache_generation: self.cache_generation + 1, // Invalidate all existing caches
